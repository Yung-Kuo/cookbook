from rest_framework import serializers
from ..models import Recipe, Category, Ingredient, RecipeIngredient

# --- 1. Base Serializers for Category and Ingredient (simple CRUD) ---

class CategorySerializer(serializers.ModelSerializer):
    class Meta:
        model = Category
        fields = ['id', 'name']
        read_only_fields = ['id'] # ID is generated by DB

class IngredientSerializer(serializers.ModelSerializer):
    class Meta:
        model = Ingredient
        fields = ['id', 'name']
        read_only_fields = ['id'] # ID is generated by DB

# --- 2. Serializer for RecipeIngredient (nested, for display AND write within Recipe) ---

class RecipeIngredientSerializer(serializers.ModelSerializer):
    # For reading/displaying: get the ingredient's name from the related Ingredient object
    name = serializers.CharField(source='ingredient.name', read_only=True)

    # For writing/input: expect the ID of an existing Ingredient
    # We rename it 'ingredient_id' for clarity in input, but 'source' maps it to the 'ingredient' ForeignKey
    # It's not strictly necessary to rename to ingredient_id, just 'ingredient' (pointing to FK) is fine.
    # Let's keep it simple and just use 'ingredient' for the FK, as discussed previously, it's cleaner.
    ingredient = serializers.PrimaryKeyRelatedField(queryset=Ingredient.objects.all())


    class Meta:
        model = RecipeIngredient
        # Fields for both reading (display) and writing (input)
        fields = ['id', 'name', 'quantity', 'unit', 'ingredient']
        read_only_fields = ['id', 'name'] # 'id' and 'name' are output only

# --- 3. Main Recipe Serializers ---

# Serializer for Reading/Displaying Recipes (GET requests)
class RecipeSerializer(serializers.ModelSerializer):
    # Nested serializer for Category to show full category details
    category = CategorySerializer(read_only=True)
    # Nested serializer for RecipeIngredient to show full ingredient details for the recipe
    # recipe_ingredients = RecipeIngredientSerializer(many=True, read_only=True)
    recipe_ingredients = serializers.SerializerMethodField(method_name='get_recipe_ingredients')

    def get_recipe_ingredients(self, obj):
        # recipe_ingredients = obj.recipeingredient_set.all()
        return RecipeIngredientSerializer(obj.recipeingredient_set.all(), many=True).data

    class Meta:
        model = Recipe
        fields = [
            'id', 'title', 'description', 'instructions',
            'prep_time', 'cook_time', 'servings',
            'category', 'recipe_ingredients',
            'created_at', 'updated_at'
        ]
        read_only_fields = ['id', 'created_at'] # updated_at is auto_now=True, handled by Django

# Serializer for Creating and Updating Recipes (POST, PUT, PATCH requests)
class RecipeWriteSerializer(serializers.ModelSerializer):
    # Expect Category ID for input (PrimaryKeyRelatedField)
    category = serializers.PrimaryKeyRelatedField(queryset=Category.objects.all(), allow_null=True) # allow_null if category can be null in model

    # Expect a list of RecipeIngredient data for input
    # This expects a list of dictionaries like [{"ingredient": 1, "quantity": 200, "unit": "g"}]
    recipe_ingredients = RecipeIngredientSerializer(many=True, required=False)


    class Meta:
        model = Recipe
        fields = [
            'id', 'title', 'description', 'instructions',
            'prep_time', 'cook_time', 'servings',
            'category', 'recipe_ingredients' # Note: created_at, updated_at are not in fields for write
        ]
        # read_only_fields = ['id'] # ID is read-only for updates, not sent for creation

    def create(self, validated_data):
        # Pop the nested data first
        recipe_ingredients_data = validated_data.pop('recipe_ingredients', [])
        
        # Create the Recipe instance
        recipe = Recipe.objects.create(**validated_data)

        # Create RecipeIngredient instances
        for ingredient_data in recipe_ingredients_data:
            # The 'ingredient' key in ingredient_data will already be an Ingredient instance
            # because PrimaryKeyRelatedField handled the lookup for us.
            RecipeIngredient.objects.create(recipe=recipe, **ingredient_data)

        return recipe

    def update(self, instance, validated_data):
        # Pop the nested data first
        recipe_ingredients_data = validated_data.pop('recipe_ingredients', None)

        # Update main Recipe fields using the parent's update method
        # This handles title, description, instructions, times, servings, and category
        instance = super().update(instance, validated_data)

        # Handle nested RecipeIngredient updates
        if recipe_ingredients_data is not None:
            # Option 1: Clear all existing and re-create (simpler for now, good for full replacement)
            instance.recipeingredient_set.all().delete()
            for ingredient_data in recipe_ingredients_data:
                RecipeIngredient.objects.create(recipe=instance, **ingredient_data)
            
            # Option 2: More sophisticated update (add/remove/modify existing).
            # This is more complex and typically requires matching by ingredient ID.
            # Example (conceptual, not full code):
            # existing_ids = set(instance.recipeingredient_set.values_list('ingredient__id', flat=True))
            # incoming_ids = set([data['ingredient'].id for data in recipe_ingredients_data])
            #
            # # Delete removed ingredients
            # for ri in instance.recipeingredient_set.all():
            #     if ri.ingredient.id not in incoming_ids:
            #         ri.delete()
            #
            # # Create/update new/modified ingredients
            # for ingredient_data in recipe_ingredients_data:
            #     ingredient_obj = ingredient_data['ingredient']
            #     if ingredient_obj.id in existing_ids:
            #         # Update existing RecipeIngredient
            #         ri = instance.recipeingredient_set.get(ingredient=ingredient_obj)
            #         ri.quantity = ingredient_data.get('quantity', ri.quantity)
            #         ri.unit = ingredient_data.get('unit', ri.unit)
            #         ri.save()
            #     else:
            #         # Create new RecipeIngredient
            #         RecipeIngredient.objects.create(recipe=instance, **ingredient_data)

        return instance